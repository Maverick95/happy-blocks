Aim of this project is to create a Tetris knock-off using web components.

Beginning notes - (as there will be a lot to do)

Remember learnings from React, truth flows downward.
i.e. information is stored in the main Game class, the happy-blocks component.
So the solution would be to move common logic down to a happyblocks general object,
as you did before with the chess stuff.
Well it's either modules, node, or this. And modules aren't allowed if you are using local
files. And you don't want to use node and webpack etc.
Yeah so I guess you're moving towards a shared module.

This is a weird combination of technologies that I haven't used before.
Maybe I've not quite done it in the right way... but we'll see how it fares for now.
I think its okay so long as you don't keep the functionality that coupled.
i.e. using the global space as a data silo or as a game management centre is BAAAD.
In my head, I know what I am thinking, probably somebody else would be able to say it better in words.
The happyblocks global object is like a SERVICE.
For example, in your rotate method, this didn't alter the input objects, it just returned a result.

TODO : add loads of tests for moveBlock! and randomizer!
TODO : something something clear Intervals when web components detached and timeouts

It has limitations, mind. But it is some sort of complete Tetris-like solution.

TODO : add test for getBlockOffsetWithNoOverlap, createBlock, CoordinateGenerators

TODO - move dedupe numeric array to helper?

What's next?

1) The Next Piece component. 

I think you need max-width, max-height, but also, some measure of what the smallest x/y are.
So you can convert coordinates into relative x/y for your display.

Take a break. Need to break down how to tackle this component in more detail later.

How will this be displayed? Should there realistically be a maximum?

No I don't think there should be a maximum.

In which case, you have a flexible-size container?

I would stick with the "conveyor belt" option to be honest.

Just because a game component tells you to do something, doesn't mean you have to do it.

For example, there will be 10 pieces generated, but that doesn't mean you have to display them all.

Look just keep it simple for now.

Work off the attribute you are given.

Unfortunately grid properties aren't animatable. Even if you added/removed elements, the movement wouldn't flow
and be pretty.
Therefore you'll have to go with top/left? Yup.

So, how to start this?

By default, create a container element with the correct width.

Then have this respond to the new attribute by changing it's width. Make this animatable.

Now we just have to display the tetrominos.

Reason I'm stalling to think here is,
you have code doing this already. But they are kind of for different things.
So I don't think I should replicate code.
So you wanted to do something cool here, and animate the movements down the changing
of the pieces.
This will involve using an interesting method that you can probably NPM as well.
It involves taking the old array, the new array, and working out what needs to happen
to the old array to replicate the new array.
Subject to some basic rules.
You see, part of me understands why you went with the idea of firing more events.
But then you'd have to somehow translate these events into attributes to give to the wc.
So no.
The simple answer to this is that controlling something through attributes alone
is a poor way of handling it.

I think I've reached a point where I can't be bothered with this project any more.

Like, I want to do something different.

Yeah, but you have to finish.

So the algorithm. What do?

It's a tricky one, because what do you want?

New array, e.g.     T Z S J O T J
Old array, e.g.     Z S J T J O O

and somehow work out the differences

Note the arrays won't necessarily be the same length, so you can't make this assumption.

Something tells me you need more info in this.

Aha! Is this more info you can give??

Like, for example, some sort of id??

This would actually clear up a lot.

Can you do this?

Y'know, a GOOD programmer would have a coder / decoder and use this via npm.










There is one attribute passed down here, a string containing the characters
of the pieces.

But you will also have an existing array of pieces.

When you get a new array, 
