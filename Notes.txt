Aim of this project is to create a Tetris knock-off using web components.

Beginning notes - (as there will be a lot to do)

KEY POINT - could you make this cumulative, i.e. parts will move downwards as
far as possible in their column space?
This btw isn't the behaviour in standard Tetris, everything just moves down by 1.

At start-up, choose a random piece from the list of pieces allowed.
This is the 'next' piece.
At points, a new piece is required.
When this happens, 
a) return the piece in the 'next' place,
b) generate a new random piece, and put this in the 'next' place.

The score.
This will need resetting on game start, incrementing by a value whenever rows are
removed.

Playing the game
There are a maximum of 5 controls in the game,
left
right
down
spin left
spin right

Remember learnings from React, truth flows downward.
i.e. information is stored in the main Game class, the happy-blocks component.
So the solution would be to move common logic down to a happyblocks general object,
as you did before with the chess stuff.
Well it's either modules, node, or this. And modules aren't allowed if you are using local
files. And you don't want to use node and webpack etc.
Yeah so I guess you're moving towards a shared module.

This is a weird combination of technologies that I haven't used before.
Maybe I've not quite done it in the right way... but we'll see how it fares for now.
I think its okay so long as you don't keep the functionality that coupled.
i.e. using the global space as a data silo or as a game management centre is BAAAD.
In my head, I know what I am thinking, probably somebody else would be able to say it better in words.
The happyblocks global object is like a SERVICE.
For example, in your rotate method, this didn't alter the input objects, it just returned a result.

TODO : add loads of tests for moveBlock! and randomizer!
TODO : something something clear Intervals when web components detached

To get thinnest slice, need to...


## 25/06/2022
Goal for this sesh -
c) Complete rows mean rows disappear with cool animation, adjusts overall score.
So when this happens, you want to -
1) break the overall game flow.
i.e. stop the current interval from executing the next game loop.
2) identify the rows that are to be removed.
Easy enough, these are returned from npm.
3) identify the rows that will be altered
Again, from npm.
4) apply a cool "pre-removal" animation HTML element representing each of the rows to be removed.
Most likely just a div with some good animations.
5) once the animation has finished, either remove these elements (eventually) or make them invisible.
6) apply a transition prop to the rows to be moved, so that the "drop" appears like a gravitational fall.
7) alter the top values of each element to be updated, and watch the magic!
8) when the entire thing has finished, be sure to run the same checks on game end, and ensure that the game
interval is properly recreated if required.

Thinnest slice I would say is to just apply the gravitational drop on the pieces, BUT also
add functionality for suspending / enabling game-flow.

First thing is, the gravitational drop itself is just adding an extra CSS class onto elements that have
landed.

Problem I can see with transition easing functions is, this won't allow the simulation of gravity
I require. Because each row will change by different amounts!

There are probably many funky ways of doing this.

I would DEFER any decision (lol, again).

And enclose any functionality that affects classes, styles, into one function.

Now anything in here is separate.
One clever thing you could do is, use the row difference as a way of obtaining style props to apply
to the piece.

I think I need to sketch out the process in code, because certain parts of the flow don't make sense.

It's basically steps 4) to 8) and how they actually occur in code, and how they sit within the event loop.
Because you need to trigger a series of intermediate events, and then resume.

Ah but I can use intervals and timeouts in this function.

At this point I would defer the decision to draw the grid in the event loop.

You're not considering how the event flow works here.

What you really WANT to happen, is for the game event flow to pause at this point in the code,
execute some other stuff, and then resume.
But this doesn't happen.
So in that case, keep this simple and consistent.
In the event loop, for this case, EXPLICITLY DEFINE that you are deleting the current interval,
running another method, and then SETTING THE NEW INTERVAL FOR THE NEXT EVENT LOOP.
So all the logic behind starting / ending event loop is in here.
Just so as long as, in the parts of code you are hijacking, when the next event loop begins,
everything is configured properly.

No offence, but actually thinking about it, the whole thing WOULD be much easier if you did setTimeout()
instead.

The only part I don't like is that in the cut-off, you have to "fake" the rest of the event loop logic.
This is kind of prone to error, because now you're continuing the flow of a set of events, that may be
quite complex.

Okay, so this is a case for why you SHOULD explicitly carve out the game loop into discrete entire blocks of events.




The game event loop is starting to feel, like, really buggy.

So, that suggests...?

Well it suggests YOU SHOULD CHANGE SOMETHING.

Or maybe its not worth it.

Remember your training. Don't bother manoveuring, chopping up code, unless it makes sense to.

It does make sense to functionalize a couple of things for safeguarding.

e.g. resetting the interval.








It has limitations, mind. But it is some sort of complete Tetris-like solution.

TODO : add test for getBlockOffsetWithNoOverlap, createBlock, CoordinateGenerators

c) Complete rows mean rows disappear with cool animation, adjusts overall score.

b)
This may be the fiddliest one.
Also because it feeds into another idea that I'm yet to incorporate.
Currently all the game loops are the same interval apart.
I think instead, you need to set a timeout for the next event loop?
What needs to happen when rows are deleted?
We need to trigger the delete animation, and the delete steps.
There are a few ways to handle the delete animation, and a few good ideas for display.
First, I think I should go with for now, is the classic old style "flashing bars" approach,
followed by the rows disappearing, and the above rows moving downwards slowly.
There's a fairly good way to simulate this that I didn't consider yet.
When pieces land, attach a class for css that sets transition for top.
Then when the rows are removed, and the other rows move down, it will animate!

2) rearrange functionality so that timeouts instead of intervals are used to set next game loop,
this means you can add delays, etc.
