Aim of this project is to create a Tetris knock-off using web components.

Just a fun little project, maybe in time I can create the same thing in
React and compare the two methods.

Beginning notes - (as there will be a lot to do)

Player's area contains a Tetris grid X wide and Y tall.
Pieces fill up this area.
If a new piece is added, couple of checks,
a) are any rows fully occupied? If so, remove the row(s),
moving all the existing rows down by the # rows removed,
add the appropriate score to the player's total.
KEY POINT - could you make this cumulative, i.e. parts will move downwards as
far as possible in their column space?
This btw isn't the behaviour in standard Tetris, everything just moves down by 1.
b) does the piece extend above the top of the playing area?
If so, GAME OVER BUDDY!

The pieces.
At start-up, choose a random piece from the list of pieces allowed.
This is the 'next' piece.
At points, a new piece is required.
When this happens, 
a) return the piece in the 'next' place,
b) generate a new random piece, and put this in the 'next' place.

The score.
This will need resetting on game start, incrementing by a value whenever rows are
removed.

Playing the game
There are a maximum of 5 controls in the game,
left
right
down
spin left
spin right

Where to start, given that I also don't know that much about web components?
Or tbh if I even should be using them.
How about something simple to start off with, like for example a score component?

Weird first start.
So I think you have the web components down.
The thing to remember is that they are entirely encapsulated.

Now can you try putting your score component inside a larger component?



Where to begin?

I'd like to make a "slot machine" style scoring element.

So all the numbers on the score are different elements, and they "roll" up or down as required
to show the new score.

But they will roll through EACH OF THE NUMBERS IN BETWEEN.

So for example, if I had score 179, and I added 180 onto this,
I would see the right-hand number roll upwards, whenever it hit 0, the next number would roll upwards,
and so on, until you reached the number in question.

This raises an interesting question about control flow.

Need to read up a bit on events first and the shadow DOM.

Interesting problem, because part of me says the event flow should work like -

a) right-hand-most spinner increases until reaches 0,
b) event is fired upwards that tells the next spinner to increase,
c) etc.

But this seems like a strange way to do it, because...

a) Right-hand-most spinner would be exempt from event flow, thus no consistent pattern,
b) Transforming one value to another known value in a roundabout manner.

Another easier method is to have each spinner "roll" upwards at the same time.
This makes more sense really. Yeah go for this one.

Should probably use templates, it looks a lot neater.

Hmm, templates and slots seem to be different from attributes.

You'll want a score attribute instead, this is what will change.

Only problem I can see is, changing the score in this way seems like the incorrect use.

Eventually, you'll have to reset the score as well.
Oh wait, that's just triggered by the parent. Fair enough.

I think we'll have to start-off very simply, by rolling something up "one" value at a time.

Now then. 

How do we roll up by a number of values?

And also, eventually, roll down??

Your idea works okay. There's probably a few optimizations in here though.

Also need to fix a bug, again this method only works for the right-most digit.

But also probably a neater way of doing the digit calculations.

A few restrictions here -

a) create web components programmatically, you can't set initial attributes.

Now that you can create this programatically and set attributes,
try changing casino-score to take instead the max-power param.

And then also do the thing where the difference appears in a nice bubble
and fades away.

But after sorting out formatting.

Formatting should be fairly easy.

Put in a flex and justify to middle.

So now what's next?

I guess having a more general think of the layout of the game.

Or the main game board?

Remember learnings from React, truth flows downward.

i.e. information is stored in the main Game class, the happy-blocks component.

Remember one simple truth - the main grid is merely a DISPLAY of information.
There might be a really simple way of displaying the grid.
i.e. with a GRID.

Hmm these are for rectangular areas.

May have to go with SVGs?

The method you choose to display the pieces needs to take into account -

a) pieces will change position,
b) rotation is possible.

Rotations would be easier if the whole grid display were down to a CSS grid.
Idea is that the CSS grid uses grid-template-areas.
But looking at it this doesn't seem fit-for-purpose either.
As in the areas define points to insert elements into.
This isn't really what I'm looking for.
So another idea is to put the behaviour of the pieces in a sub-component.

But this may be a minefield as well.

Because I don't want to split up the logic, I don't think the display pieces
should have separate logic in them to display the pieces. Or duplicated.

In other words they should just directly translate attributes.

This is fine, why not?

Hmm this is what's weird.

Because in the game component, the logical wheel-house, it will be determined
here which spaces the piece will fill. Because it needs this to determine logic
for things like, when the piece hits the bottom, its current position, whether it
can move left and right, etc.

Moving display logic down to the component means you'll duplicate this.

So the solution would be to move common logic down to a happyblocks general object,
as you did before with the chess stuff.

Well it's either modules, node, or this. And modules aren't allowed if you are using local
files. And you don't want to use node and webpack etc.

Yeah so I guess you're moving towards a shared module.

And in here, this will be the shared logic.

Which is, what exactly?

Well for starters we need some sort of lookup based on the pieces.

So there are 7 pieces, O S Z T L J I

Each piece requires -

a) an initial setup, and,
b) a method of rotation.

The initial setup is fine, just an array of coords.
The rotation is also fine, you just need the one coord to rotate around. (the origin)

This is rotation around 90 degrees as well, so...

x -> -y -> -x ->  y -> x
y ->  x -> -y -> -x -> y

Easy.

For each piece, you just store then...

a) coordinates of origin,
b) coordinates of each piece relative to origin.

In this sense, working out collisions is pretty easy.

Each piece should also have an id, this will be used to generate the HTML id.

We will have to hold data in a grid array structure.

Because Tetris only moves one space at a time, collision detection is fairly easy.

What's not so easy is.

Remember that in Tetris, whenever a row is filled, the row needs to vanish.

This is actually making me think, that you should draw each individual square
of a Tetrimino as a separate entity.

Because when you delete certain rows, this is just deleting some entities.

I think you should start off with something definitely simple.

Tricky to think about a first slice here.

I guess there is no first slice.

In that case just build the damn thing.

As a web component, the only key props are width and height.

And maybe other key settings (TBD).

Visually, the grid needs to display its contents. So start off with this.

At the very least, you'll probably need to store, in each grid element,

a) id of the element,
b) this looks up to a type,
c) both these things denote the style on an element.

Should be noted, the chances of you actually changing the grid size mid-game is... none.

So drawing the grid is a formality really.

When I think about it... drawing the grid??? As in, updating the styles of EVERY piece element
every time?? You don't need to do that surely.

Think about it. This is a discrete game.
But also remember what you've learnt so far. Optimize when you have problems.
You could cut off a lot of possibilities here.
So you SHOULD be drawing as if from nothing.

Keep this in mind with this project. See if things work out better.

So for each piece, you should search for element. If it exists, update the style.
Don't use CSS classes for this, the searching / removing options for DOMTokenList is limited.
So append styles instead.

This means against each piece type, storing some style props.

So what's the next step here?

Well, you need now to store an active piece somehow against the grid.
So there is the concept of the active piece.
This piece needs to store quite a bit of info.
Needs to have the list of piece ids.
But it's more just the list of piece coordinates really.

a) piece main coordinate x and y,
b) list of relative pieces, each with x,y, id.

Should be quite easily to set the active piece, and then add individual pieces as ids.

The easy part as well is, all you do is just stop referencing the active piece.

Yay!

Next big step is in working out things like piece rotations and movements one in each direction.

This is where the webpack / unit testing comes in.

So now I have a way of 

