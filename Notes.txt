Aim of this project is to create a Tetris knock-off using web components.

Just a fun little project, maybe in time I can create the same thing in
React and compare the two methods.

Beginning notes - (as there will be a lot to do)

Player's area contains a Tetris grid X wide and Y tall.
Pieces fill up this area.
If a new piece is added, couple of checks,
a) are any rows fully occupied? If so, remove the row(s),
moving all the existing rows down by the # rows removed,
add the appropriate score to the player's total.
KEY POINT - could you make this cumulative, i.e. parts will move downwards as
far as possible in their column space?
This btw isn't the behaviour in standard Tetris, everything just moves down by 1.
b) does the piece extend above the top of the playing area?
If so, GAME OVER BUDDY!

The pieces.
At start-up, choose a random piece from the list of pieces allowed.
This is the 'next' piece.
At points, a new piece is required.
When this happens, 
a) return the piece in the 'next' place,
b) generate a new random piece, and put this in the 'next' place.

The score.
This will need resetting on game start, incrementing by a value whenever rows are
removed.

Playing the game
There are a maximum of 5 controls in the game,
left
right
down
spin left
spin right

Where to start, given that I also don't know that much about web components?
Or tbh if I even should be using them.
How about something simple to start off with, like for example a score component?

Weird first start.
So I think you have the web components down.
The thing to remember is that they are entirely encapsulated.

Now can you try putting your score component inside a larger component?



Where to begin?

I'd like to make a "slot machine" style scoring element.

So all the numbers on the score are different elements, and they "roll" up or down as required
to show the new score.

But they will roll through EACH OF THE NUMBERS IN BETWEEN.

So for example, if I had score 179, and I added 180 onto this,
I would see the right-hand number roll upwards, whenever it hit 0, the next number would roll upwards,
and so on, until you reached the number in question.

This raises an interesting question about control flow.

Need to read up a bit on events first and the shadow DOM.

Interesting problem, because part of me says the event flow should work like -

a) right-hand-most spinner increases until reaches 0,
b) event is fired upwards that tells the next spinner to increase,
c) etc.

But this seems like a strange way to do it, because...

a) Right-hand-most spinner would be exempt from event flow, thus no consistent pattern,
b) Transforming one value to another known value in a roundabout manner.

Another easier method is to have each spinner "roll" upwards at the same time.
This makes more sense really. Yeah go for this one.

Should probably use templates, it looks a lot neater.

Hmm, templates and slots seem to be different from attributes.

You'll want a score attribute instead, this is what will change.

Only problem I can see is, changing the score in this way seems like the incorrect use.

Eventually, you'll have to reset the score as well.
Oh wait, that's just triggered by the parent. Fair enough.

I think we'll have to start-off very simply, by rolling something up "one" value at a time.

Now then. 

How do we roll up by a number of values?

And also, eventually, roll down??

Your idea works okay. There's probably a few optimizations in here though.

Also need to fix a bug, again this method only works for the right-most digit.

But also probably a neater way of doing the digit calculations.

A few restrictions here -

a) create web components programmatically, you can't set initial attributes.

Now that you can create this programatically and set attributes,
try changing casino-score to take instead the max-power param.

And then also do the thing where the difference appears in a nice bubble
and fades away.

But after sorting out formatting.

Formatting should be fairly easy.

Put in a flex and justify to middle.

So now what's next?

I guess having a more general think of the layout of the game.

Or the main game board?

Remember learnings from React, truth flows downward.

i.e. information is stored in the main Game class, the happy-blocks component.

Remember one simple truth - the main grid is merely a DISPLAY of information.
There might be a really simple way of displaying the grid.
i.e. with a GRID.

Hmm these are for rectangular areas.

May have to go with SVGs?

The method you choose to display the pieces needs to take into account -

a) pieces will change position,
b) rotation is possible.

Rotations would be easier if the whole grid display were down to a CSS grid.
Idea is that the CSS grid uses grid-template-areas.
But looking at it this doesn't seem fit-for-purpose either.
As in the areas define points to insert elements into.
This isn't really what I'm looking for.
So another idea is to put the behaviour of the pieces in a sub-component.

But this may be a minefield as well.

Because I don't want to split up the logic, I don't think the display pieces
should have separate logic in them to display the pieces. Or duplicated.

In other words they should just directly translate attributes.

This is fine, why not?

Hmm this is what's weird.

Because in the game component, the logical wheel-house, it will be determined
here which spaces the piece will fill. Because it needs this to determine logic
for things like, when the piece hits the bottom, its current position, whether it
can move left and right, etc.

Moving display logic down to the component means you'll duplicate this.

So the solution would be to move common logic down to a happyblocks general object,
as you did before with the chess stuff.

Well it's either modules, node, or this. And modules aren't allowed if you are using local
files. And you don't want to use node and webpack etc.

Yeah so I guess you're moving towards a shared module.

And in here, this will be the shared logic.

Which is, what exactly?

Well for starters we need some sort of lookup based on the pieces.

So there are 7 pieces, O S Z T L J I

Each piece requires -

a) an initial setup, and,
b) a method of rotation.

The initial setup is fine, just an array of coords.
The rotation is also fine, you just need the one coord to rotate around. (the origin)

This is rotation around 90 degrees as well, so...

x -> -y -> -x ->  y -> x
y ->  x -> -y -> -x -> y

Easy.

For each piece, you just store then...

a) coordinates of origin,
b) coordinates of each piece relative to origin.

In this sense, working out collisions is pretty easy.

Each piece should also have an id, this will be used to generate the HTML id.

We will have to hold data in a grid array structure.

Because Tetris only moves one space at a time, collision detection is fairly easy.

What's not so easy is.

Remember that in Tetris, whenever a row is filled, the row needs to vanish.

This is actually making me think, that you should draw each individual square
of a Tetrimino as a separate entity.

Because when you delete certain rows, this is just deleting some entities.

I think you should start off with something definitely simple.

Tricky to think about a first slice here.

I guess there is no first slice.

In that case just build the damn thing.

As a web component, the only key props are width and height.

And maybe other key settings (TBD).

Visually, the grid needs to display its contents. So start off with this.

At the very least, you'll probably need to store, in each grid element,

a) id of the element,
b) this looks up to a type,
c) both these things denote the style on an element.

Should be noted, the chances of you actually changing the grid size mid-game is... none.

So drawing the grid is a formality really.

When I think about it... drawing the grid??? As in, updating the styles of EVERY piece element
every time?? You don't need to do that surely.

Think about it. This is a discrete game.
But also remember what you've learnt so far. Optimize when you have problems.
You could cut off a lot of possibilities here.
So you SHOULD be drawing as if from nothing.

Keep this in mind with this project. See if things work out better.

So for each piece, you should search for element. If it exists, update the style.
Don't use CSS classes for this, the searching / removing options for DOMTokenList is limited.
So append styles instead.

This means against each piece type, storing some style props.

So what's the next step here?

Well, you need now to store an active piece somehow against the grid.
So there is the concept of the active piece.
This piece needs to store quite a bit of info.
Needs to have the list of piece ids.
But it's more just the list of piece coordinates really.

a) piece main coordinate x and y,
b) list of relative pieces, each with x,y, id.

Should be quite easily to set the active piece, and then add individual pieces as ids.

The easy part as well is, all you do is just stop referencing the active piece.

Yay!

Next big step is in working out things like piece rotations and movements one in each direction.

This is where the webpack / unit testing comes in.

So now I have a way of assigning a happyblocks global object.

And this is set within npm.

This is a weird combination of technologies that I haven't used before.
Maybe I've not quite done it in the right way... but we'll see how it fares for now.
I think its okay so long as you don't keep the functionality that coupled.
i.e. using the global space as a data silo is BAAAD.
In my head, I know what I am thinking, probably somebody else would be able to say it better in words.
The happyblocks global object is like a SERVICE.
For example, in your rotate method, this didn't alter the input objects, it just returned a result.



Rotation is done, so the next big thing I want to do is, I want to get the main game flow going.

Write out in words what happens -

1) Game start, grid is empty, current block is null
2) First step is to have a method that randomly selects a piece. (fix to standard)
NOTE - same method also knows which is the NEXT piece to display.
(this is maybe something to do)
3) Game has an "event period" - time until the next "event" is triggered.
4) Event is triggered, decision process is...

a) Is current block null? If yes, initiate next piece with some way of determining start position
at the top of the game area. Set current block to this, add to grid, etc, blah blah blah...
(for now fix to standard)

b) Current block is not null -
this means piece is prompted to move down one slot
Ask the question, "can the piece be moved downward?"
If yes, then move downward.
If no, then... erm, what exactly?
Piece has stopped moving.
[ INSERT PART THAT CHECKS THAT ROWS ARE COMPLETE AND REMOVES THEM AND INCREASES SCORE!!! ]
Then check if piece is out-of-bounds.
If yes, game over!
If no, then block is null. Detaches.

TODO : add loads of tests for moveBlock! and randomizer!

TODO : something something clear Intervals when web components detached

To get thinnest slice, need to...

a) Initial piece location needs to be clear, DONE
b) Game end needs handling, SORT-OF DONE
c) Complete rows mean rows disappear with cool animation, adjusts overall score.
d) Incorporating with game score and the general layout.
e) The event tree!


TODO : add test for getBlockOffsetWithNoOverlap, createBlock, CoordinateGenerators

c) Complete rows mean rows disappear with cool animation, adjusts overall score.

This is the most fun!

The calculation may require some extra properties.

Two major areas to consider here -

a) computation, DONE
b) display.

b)
This may be the fiddliest one.
Also because it feeds into another idea that I'm yet to incorporate.
Currently all the game loops are the same interval apart.
I think instead, you need to set a timeout for the next event loop?
What needs to happen when rows are deleted?
We need to trigger the delete animation, and the delete steps.
There are a few ways to handle the delete animation, and a few good ideas for display.
First, I think I should go with for now, is the classic old style "flashing bars" approach,
followed by the rows disappearing, and the above rows moving downwards slowly.
There's a fairly good way to simulate this that I didn't consider yet.
When pieces land, attach a class for css that sets transition for top.
Then when the rows are removed, and the other rows move down, it will animate!

2) rearrange functionality so that timeouts instead of intervals are used to set next game loop,
this means you can add delays, etc.

